package lab2.simulate;
import lab2.event.*;
import lab2.simulate.Buffer;

public class GBNSender {
		
	private double timeoutInS;	
	private double packetSizeInBits;
	private double headerSizeInBits;
	private double propDelayInS;	
	private double bitErrorRate;
	private double frameTransmitInS;
	private double headerTransmitInS;
	private int bufferSize;
	
	public GBNSender(
			double timeoutInS, double packetSizeInBits, double headerSizeInBits, double linkRateInBPS, double propDelayInS, double bitErrorRate, int bufferSize){
		this.timeoutInS = timeoutInS;
		this.packetSizeInBits = packetSizeInBits;
		this.headerSizeInBits = headerSizeInBits;
		this.propDelayInS = propDelayInS;
		frameTransmitInS = (headerSizeInBits + packetSizeInBits)/linkRateInBPS;
		headerTransmitInS = headerSizeInBits/linkRateInBPS;
		this.bitErrorRate = bitErrorRate;
		this.bufferSize = bufferSize;
		
	}
	
	public Event send(int seqNumber, double currentTimeInS){
		//first stretch of the channel begins after processing the FRAME must take into account time to transmit FRAME
		Channel.simulate(bitErrorRate, propDelayInS, currentTimeInS + frameTransmitInS, packetSizeInBits + headerSizeInBits);
		boolean forwardDropped = Channel.isPacketDropped();
		boolean forwardError = Channel.isPacketError();
		
		//second stretch of the channel begins after getting the FRAME, must also take into account time to transmit ACK
		Channel.simulate(bitErrorRate, propDelayInS, Channel.getLastTime() + headerTransmitInS, headerSizeInBits);
		boolean reverseDropped = Channel.isPacketDropped();
		boolean reverseError = Channel.isPacketError();
		
		if(forwardDropped || reverseDropped){
			return null;
		}
		
		//sender gets the ack
		return new Event(EventType.ACK, Channel.getLastTime(), (seqNumber+1)%2, forwardError || reverseError );
	}
	
	public double simulate(int successfulArrivals, boolean nackEnabled){
		Event e;
		int count = 0;
		int seqNumber = 0;
		double currentTimeInS = 0;
		EventScheduler eventScheduler = new EventScheduler();
		Buffer buffer = new Buffer(bufferSize, seqNumber);
		
		while( count < successfulArrivals ){
			//process next event
			e = eventScheduler.dequeue();
			if(e != null){
				currentTimeInS = e.getTime();
				if(e.getType() == EventType.TO){	
					
					//set all packets in the buffer to "unsent" state
					buffer.setAllUnsent();
					//try to send again
					//if the next event time > than the time at which the next unsent packet can be finished sending
					if(eventScheduler.getNextTime() > currentTimeInS + frameTransmitInS){
						//check to make sure I can send at least one packet. if i can, set timeout
						eventScheduler.purgeTimeouts();
						eventScheduler.queue(new Event(EventType.TO, currentTimeInS+timeoutInS+frameTransmitInS));	
						while(buffer.nextUnsent != -1 && eventScheduler.getNextTime() > currentTimeInS + frameTransmitInS){
							eventScheduler.queue(send(buffer.sendNextFrame(currentTimeInS), currentTimeInS));
							currentTimeInS = currentTimeInS + frameTransmitInS;						
						}
					}
		
				}else if(!e.isError()){
				
					//this is an ack
					//slide the window until we've counted all the ack'd packets
					//prepare new packets
					//shift until the next unacked packet is at the front
					while(buffer.getFront().sn != e.getSN()){						
						count++;
						System.out.println("Count! " + count);
						buffer.shift();
						buffer.prepareFrame(packetSizeInBits+headerSizeInBits, seqNumber);
						seqNumber = (seqNumber+1)%(bufferSize+1);
					}

					buffer.print();
					//set next timeout
					if(buffer.getFront().time != -1 && buffer.getFront().time != -2){
						eventScheduler.purgeTimeouts();
						eventScheduler.queue(new Event(EventType.TO, buffer.getFront().time+timeoutInS));	
					}else{
						if(eventScheduler.getNextTime() > currentTimeInS + frameTransmitInS){
							//check to make sure I can send at least one packet. if i can, set timeout
							eventScheduler.purgeTimeouts();
							eventScheduler.queue(new Event(EventType.TO, currentTimeInS+timeoutInS+frameTransmitInS));	
						}
					}
					
					//keep trying to send any unsent packets
					while(buffer.nextUnsent != -1 && eventScheduler.getNextTime() > currentTimeInS + frameTransmitInS){
							eventScheduler.queue(send(buffer.sendNextFrame(currentTimeInS + frameTransmitInS), currentTimeInS));
							currentTimeInS = currentTimeInS + frameTransmitInS;						
					}
					
				}else if(e.isError()){
					//if the event is actually in error, pretend we didn't get it and keep trying to send the buffer
					//if the next event time > than the time at which the next unsent packet can be finished sending
					while(buffer.nextUnsent != -1 && eventScheduler.getNextTime() > currentTimeInS + frameTransmitInS){
							eventScheduler.queue(send(buffer.sendNextFrame(currentTimeInS + frameTransmitInS), currentTimeInS));
							currentTimeInS = currentTimeInS + frameTransmitInS;						
					}
					
				}
			}else{
				
				//prepare a buffer of n packets
				for(int i = 0; i < bufferSize; i++){
					buffer.prepareFrame(packetSizeInBits+headerSizeInBits, seqNumber);
					seqNumber = (seqNumber+1)%(bufferSize+1);
				}
				
				//if the next event time > than the time at which the next unsent packet can be finished sending
				if(eventScheduler.getNextTime() > currentTimeInS + frameTransmitInS){
					//check to make sure I can send at least one packet. if i can, set timeout
					eventScheduler.purgeTimeouts();
					eventScheduler.queue(new Event(EventType.TO, currentTimeInS+timeoutInS+frameTransmitInS));	
					while(buffer.nextUnsent != -1 && eventScheduler.getNextTime() > currentTimeInS + frameTransmitInS){
						eventScheduler.queue(send(buffer.sendNextFrame(currentTimeInS + frameTransmitInS), currentTimeInS));
						currentTimeInS = currentTimeInS + frameTransmitInS;						
					}
				}
				
				
				//if there's an event that occurs during processing break and let handler get it
			}
			
		}
		return (count*packetSizeInBits)/(currentTimeInS); //returns throughput in bps
		
	}

}
