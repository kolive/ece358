package simulate;
import lab2.event.*;

public class ABPSender {
	
	private EventScheduler es;
	
	private int sn;
	private int nextSN;
	private double timeoutValue;
	private double currentTime;
	
	private double packetSize;
	private double headerSize;
	private double linkRate;
	private double processTime;
	private double propDelay;
	
	public ABPSender(
			double timeout, double ps, double hs, double lr, double pd,
			EventScheduler es){
		sn = 0;
		nextSN = 1;
		timeoutValue = timeout;
		currentTime = 0;
		packetSize = ps;
		headerSize = hs;
		linkRate = lr;
		propDelay = pd;
		this.es = es;
		processTime = (hs + ps)/lr;
	}
	
	public Event send(int sn){
		boolean forwardError = false;
		boolean reverseError = false;
		if(forwardError || reverseError){
			return null;
		}
		
		boolean headerError = false;
		return new Event(EventType.ACK, currentTime + propDelay, (sn+1)%2, headerError);
	}
	
	public void simulate(double simulationTime){
		double transferTime;
		Event e;
		while((e = es.dequeue()) != null || currentTime <= simulationTime ){
			//process next event
			if(e != null){
				if(e.getType() == EventType.TO){
					currentTime = e.getTime();
					transferTime = currentTime + processTime;
					es.queue(new Event(EventType.TO, transferTime+timeoutValue));	
					send(sn);
				}else if(!e.isError()){
					currentTime = e.getTime();
					transferTime = currentTime + processTime;
					if(e.getSN() == nextSN){
						es.purgeTimeouts();
						sn = (sn+1)%2;
						nextSN = (nextSN+1)%2;
						es.queue(new Event(EventType.TO, transferTime+timeoutValue));	
						send(sn);
					}
					
				}
			}else{
				currentTime = e.getTime();
				transferTime = currentTime + processTime;
				es.queue(new Event(EventType.TO, transferTime+timeoutValue));	
				send(sn);
			}
			
		}
	}

}
